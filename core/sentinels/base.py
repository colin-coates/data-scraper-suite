# Copyright (c) 2024 Mountain Jewels Intelligence. All rights reserved.
#
# This software is proprietary and confidential. Unauthorized copying,
# modification, distribution, or use is strictly prohibited.

"""
Sentinel Base Classes for MJ Data Scraper Suite

Provides monitoring, alerting, and automated response systems for scraping operations.
Sentinels watch for specific conditions and trigger alerts or corrective actions.
"""

import asyncio
import logging
import time
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Dict, List, Any, Optional, Callable, Union
from collections import defaultdict, deque

from ..scrape_telemetry import get_global_telemetry_collector

logger = logging.getLogger(__name__)


class SentinelSeverity(Enum):
    """Severity levels for sentinel alerts."""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"


class SentinelStatus(Enum):
    """Status of sentinel monitoring."""
    ACTIVE = "active"
    INACTIVE = "inactive"
    ALERTING = "alerting"
    MAINTENANCE = "maintenance"


@dataclass
class SentinelAlert:
    """Alert generated by a sentinel."""
    sentinel_name: str
    severity: SentinelSeverity
    message: str
    details: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.utcnow)
    resolved: bool = False
    resolved_at: Optional[datetime] = None
    alert_id: str = field(default_factory=lambda: f"alert_{int(time.time() * 1000)}")

    def resolve(self) -> None:
        """Mark the alert as resolved."""
        self.resolved = True
        self.resolved_at = datetime.utcnow()
        logger.info(f"Alert {self.alert_id} resolved: {self.message}")

    def to_dict(self) -> Dict[str, Any]:
        """Convert alert to dictionary."""
        return {
            "alert_id": self.alert_id,
            "sentinel_name": self.sentinel_name,
            "severity": self.severity.value,
            "message": self.message,
            "details": self.details,
            "timestamp": self.timestamp.isoformat(),
            "resolved": self.resolved,
            "resolved_at": self.resolved_at.isoformat() if self.resolved_at else None
        }


@dataclass
class SentinelConfig:
    """Configuration for sentinel instances."""
    name: str
    enabled: bool = True
    check_interval: float = 60.0  # seconds
    alert_threshold: int = 3  # consecutive failures before alerting
    cooldown_period: float = 300.0  # seconds between alerts
    severity: SentinelSeverity = SentinelSeverity.WARNING
    auto_resolve: bool = True
    alert_channels: List[str] = field(default_factory=lambda: ["log"])

    def validate(self) -> None:
        """Validate sentinel configuration."""
        if self.check_interval <= 0:
            raise ValueError("check_interval must be positive")
        if self.alert_threshold < 1:
            raise ValueError("alert_threshold must be at least 1")
        if self.cooldown_period < 0:
            raise ValueError("cooldown_period cannot be negative")


class SentinelBase(ABC):
    """
    Base class for all sentinels in the MJ Data Scraper Suite.

    Sentinels monitor specific conditions and trigger alerts or actions
    when predefined thresholds are exceeded or conditions are met.
    """

    def __init__(self, config: SentinelConfig):
        self.config = config
        self.config.validate()

        self.status = SentinelStatus.ACTIVE
        self.last_check_time = 0.0
        self.consecutive_failures = 0
        self.last_alert_time = 0.0
        self.active_alerts: List[SentinelAlert] = []
        self.alert_history: deque[SentinelAlert] = deque(maxlen=1000)

        # Callbacks
        self.on_alert: Optional[Callable[[SentinelAlert], None]] = None
        self.on_resolve: Optional[Callable[[SentinelAlert], None]] = None
        self.on_status_change: Optional[Callable[[SentinelStatus, SentinelStatus], None]] = None

        # Telemetry integration
        self.telemetry_collector = get_global_telemetry_collector()

        logger.info(f"Sentinel {config.name} initialized with check_interval={config.check_interval}s")

    @abstractmethod
    async def check_condition(self) -> tuple[bool, str, Dict[str, Any]]:
        """
        Check the specific condition this sentinel monitors.

        Returns:
            tuple: (is_healthy, status_message, additional_data)
        """
        pass

    @abstractmethod
    def get_sentinel_type(self) -> str:
        """Return the type of sentinel (e.g., 'performance', 'compliance', 'system')."""
        pass

    async def execute_check(self) -> None:
        """
        Execute a single check cycle.

        This method handles the check execution, alert generation, and state management.
        """
        if self.status != SentinelStatus.ACTIVE:
            return

        try:
            current_time = time.time()

            # Check if it's time for another check
            if current_time - self.last_check_time < self.config.check_interval:
                return

            self.last_check_time = current_time

            # Execute the specific condition check
            is_healthy, message, details = await self.check_condition()

            if is_healthy:
                # Reset consecutive failures on success
                if self.consecutive_failures > 0:
                    logger.info(f"Sentinel {self.config.name} recovered: {message}")
                    await self._resolve_active_alerts()
                self.consecutive_failures = 0
            else:
                # Increment consecutive failures
                self.consecutive_failures += 1
                logger.warning(f"Sentinel {self.config.name} condition failed ({self.consecutive_failures}/{self.config.alert_threshold}): {message}")

                # Check if we should alert
                if (self.consecutive_failures >= self.config.alert_threshold and
                    current_time - self.last_alert_time >= self.config.cooldown_period):
                    await self._generate_alert(message, details)
                    self.last_alert_time = current_time

        except Exception as e:
            logger.error(f"Sentinel {self.config.name} check failed with exception: {e}")
            self.consecutive_failures += 1

            if self.consecutive_failures >= self.config.alert_threshold:
                await self._generate_alert(f"Check execution failed: {str(e)}", {"exception": str(e)})

    async def _generate_alert(self, message: str, details: Dict[str, Any]) -> None:
        """Generate and handle a new alert."""
        alert = SentinelAlert(
            sentinel_name=self.config.name,
            severity=self.config.severity,
            message=message,
            details=details
        )

        self.active_alerts.append(alert)
        self.alert_history.append(alert)

        # Update status if this is our first active alert
        if len(self.active_alerts) == 1:
            await self._change_status(SentinelStatus.ALERTING)

        # Call alert callback
        if self.on_alert:
            try:
                self.on_alert(alert)
            except Exception as e:
                logger.error(f"Alert callback failed for {self.config.name}: {e}")

        # Send alert to configured channels
        await self._send_alert_to_channels(alert)

        logger.warning(f"Sentinel {self.config.name} generated {alert.severity.value} alert: {alert.message}")

    async def _resolve_active_alerts(self) -> None:
        """Resolve all active alerts if auto-resolve is enabled."""
        if not self.config.auto_resolve:
            return

        resolved_alerts = []
        for alert in self.active_alerts:
            if not alert.resolved:
                alert.resolve()
                resolved_alerts.append(alert)

                if self.on_resolve:
                    try:
                        self.on_resolve(alert)
                    except Exception as e:
                        logger.error(f"Resolve callback failed for {self.config.name}: {e}")

        self.active_alerts.clear()

        if resolved_alerts and self.status == SentinelStatus.ALERTING:
            await self._change_status(SentinelStatus.ACTIVE)

        if resolved_alerts:
            logger.info(f"Sentinel {self.config.name} resolved {len(resolved_alerts)} alerts")

    async def _change_status(self, new_status: SentinelStatus) -> None:
        """Change sentinel status and notify callbacks."""
        old_status = self.status
        self.status = new_status

        if self.on_status_change and old_status != new_status:
            try:
                self.on_status_change(old_status, new_status)
            except Exception as e:
                logger.error(f"Status change callback failed for {self.config.name}: {e}")

        logger.info(f"Sentinel {self.config.name} status changed: {old_status.value} -> {new_status.value}")

    async def _send_alert_to_channels(self, alert: SentinelAlert) -> None:
        """Send alert to configured channels."""
        for channel in self.config.alert_channels:
            try:
                if channel == "log":
                    # Already logged above
                    pass
                elif channel == "email":
                    await self._send_email_alert(alert)
                elif channel == "slack":
                    await self._send_slack_alert(alert)
                elif channel == "webhook":
                    await self._send_webhook_alert(alert)
                else:
                    logger.warning(f"Unknown alert channel: {channel}")
            except Exception as e:
                logger.error(f"Failed to send alert to {channel}: {e}")

    async def _send_email_alert(self, alert: SentinelAlert) -> None:
        """Send alert via email (placeholder for implementation)."""
        # TODO: Implement email integration
        logger.debug(f"Would send email alert: {alert.message}")

    async def _send_slack_alert(self, alert: SentinelAlert) -> None:
        """Send alert via Slack (placeholder for implementation)."""
        # TODO: Implement Slack integration
        logger.debug(f"Would send Slack alert: {alert.message}")

    async def _send_webhook_alert(self, alert: SentinelAlert) -> None:
        """Send alert via webhook (placeholder for implementation)."""
        # TODO: Implement webhook integration
        logger.debug(f"Would send webhook alert: {alert.message}")

    def get_metrics(self) -> Dict[str, Any]:
        """Get sentinel performance metrics."""
        return {
            "sentinel_name": self.config.name,
            "sentinel_type": self.get_sentinel_type(),
            "status": self.status.value,
            "check_interval": self.config.check_interval,
            "consecutive_failures": self.consecutive_failures,
            "active_alerts": len(self.active_alerts),
            "total_alerts": len(self.alert_history),
            "last_check_time": self.last_check_time,
            "last_alert_time": self.last_alert_time,
            "severity": self.config.severity.value
        }

    def get_active_alerts(self) -> List[SentinelAlert]:
        """Get list of currently active alerts."""
        return self.active_alerts.copy()

    def get_alert_history(self, limit: Optional[int] = None) -> List[SentinelAlert]:
        """Get alert history, optionally limited to most recent."""
        alerts = list(self.alert_history)
        if limit:
            alerts = alerts[-limit:]
        return alerts

    def reset_metrics(self) -> None:
        """Reset sentinel metrics (useful for testing)."""
        self.consecutive_failures = 0
        self.last_alert_time = 0.0
        self.active_alerts.clear()
        logger.info(f"Metrics reset for sentinel {self.config.name}")

    async def start_monitoring(self) -> None:
        """Start the sentinel monitoring loop."""
        self.status = SentinelStatus.ACTIVE
        logger.info(f"Started monitoring for sentinel {self.config.name}")

        while self.status == SentinelStatus.ACTIVE:
            try:
                await self.execute_check()
                await asyncio.sleep(min(self.config.check_interval, 1.0))  # Don't sleep too long
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Monitoring loop error for {self.config.name}: {e}")
                await asyncio.sleep(5.0)  # Brief pause on error

        logger.info(f"Stopped monitoring for sentinel {self.config.name}")

    def stop_monitoring(self) -> None:
        """Stop the sentinel monitoring."""
        self.status = SentinelStatus.INACTIVE
        logger.info(f"Monitoring stopped for sentinel {self.config.name}")

    def set_maintenance_mode(self) -> None:
        """Put sentinel in maintenance mode (suppresses alerts)."""
        self.status = SentinelStatus.MAINTENANCE
        logger.info(f"Maintenance mode enabled for sentinel {self.config.name}")

    def __str__(self) -> str:
        return f"{self.__class__.__name__}(name={self.config.name}, status={self.status.value}, alerts={len(self.active_alerts)})"


# Global sentinel registry
_sentinel_registry: Dict[str, SentinelBase] = {}


def register_sentinel(sentinel: SentinelBase) -> None:
    """Register a sentinel in the global registry."""
    _sentinel_registry[sentinel.config.name] = sentinel
    logger.info(f"Registered sentinel: {sentinel.config.name}")


def unregister_sentinel(name: str) -> None:
    """Unregister a sentinel from the global registry."""
    if name in _sentinel_registry:
        del _sentinel_registry[name]
        logger.info(f"Unregistered sentinel: {name}")


def get_registered_sentinels() -> Dict[str, SentinelBase]:
    """Get all registered sentinels."""
    return _sentinel_registry.copy()


def get_sentinel(name: str) -> Optional[SentinelBase]:
    """Get a specific registered sentinel by name."""
    return _sentinel_registry.get(name)


async def start_all_sentinels() -> None:
    """Start monitoring for all registered sentinels."""
    tasks = []
    for sentinel in _sentinel_registry.values():
        if sentinel.config.enabled:
            task = asyncio.create_task(sentinel.start_monitoring())
            tasks.append(task)

    if tasks:
        logger.info(f"Started monitoring for {len(tasks)} sentinels")
        await asyncio.gather(*tasks, return_exceptions=True)
    else:
        logger.info("No sentinels to start")


def stop_all_sentinels() -> None:
    """Stop monitoring for all registered sentinels."""
    for sentinel in _sentinel_registry.values():
        sentinel.stop_monitoring()
    logger.info("Stopped all sentinels")
